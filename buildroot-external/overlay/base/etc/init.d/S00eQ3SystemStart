#!/bin/sh
#
# set System Start Led Signal
#

CFG_TEMPLATE_DIR=/etc/config_templates

# function to identify the host system used
identify_host() {

  # identify the RaspberryPi version used
  cat /proc/cpuinfo | grep 'Revision' | awk '{print $3}' | grep -q 2082
  if [[ $? -eq 0 ]]; then
    HOST="rpi3"
    HM_MODE="HmRF"
    UART_DEV="/dev/ttyAMA0"
  else
    HOST="rpi2"
    HM_MODE="HmIP"
    UART_DEV="/dev/bcm2835-raw-uart"
  fi

  echo "HOST=${HOST}" >>/var/ids
  echo "HM_MODE=${HM_MODE}" >>/var/ids
  echo "UART_DEV=${UART_DEV}" >>/var/ids
}

# function to resize /usr/local partition to maximum SD card size
resize_usrlocal() {

  DEV=$(mount | grep /usr/local | cut -d' ' -f1 | head -c-3)
  PARTNUM=$(mount | grep /usr/local | cut -d' ' -f1 | tail -c2)

  # only continue if .fresh file exists
  if [[ ! -r /usr/local/.fresh ]]; then
    return
  fi

  # find out maximum SD card size (in cylinders)
  START_CHS=$(parted -s ${DEV} unit chs print | grep "^ ${PARTNUM} " | awk '{print $2}')
  END_CHS=$(parted -s ${DEV} unit chs print | grep "^ ${PARTNUM} " | awk '{print $3}')
  MAX_CHS=$(parted -s ${DEV} unit chs print | grep "Disk ${DEV}" | cut -d' ' -f3)

  # only continue if END_CHS != MAX_CHS
  if [[ -z "${START_CHS}" || -z "${END_CHS}" || -z "${MAX_CHS}" || "${END_CHS}" == "${MAX_CHS}" ]]; then
    return
  fi

  # umount /usr/local to regenerate it
  umount /usr/local

  # remove the third partition (/usr/local) and recreate it with
  # MAX_CHS
  parted -s ${DEV} rm ${PARTNUM}
  parted -s ${DEV} mkpart primary ${START_CHS} ${MAX_CHS}

  # we create a clean ext4 partition now
  mkfs.ext4 -F ${DEV}p${PARTNUM}

  # mount /usr/local again
  mount /usr/local
}

init() {

  # identify the host
  identify_host

  # depending on the HomeMatic mode (HmRF, HmIP) we
  # have to load different kernel modules.
  if [[ ${HM_MODE} == "HmIP" ]]; then
    # HM/HmIP Dual Protocol
    modprobe bcm2835_raw_uart
    modprobe eq3_char_loop
  else
    # use standard PL011 UART
    modprobe amba-pl011
  fi

  # load watchdog kernel module
  modprobe bcm2835_wdt nowayout=1 heartbeat=15

  # initialize a potentially existing PiFace Shim RTC clock (MCP7940N)
  modprobe i2c_bcm2708
  modprobe i2c-dev
  i2cset -y 1 0x6f 0x08 0x47 2>/dev/null
  if [ $? -eq 0 ]; then
    modprobe i2c:mcp7941x
    echo mcp7941x 0x6f >/sys/class/i2c-dev/i2c-1/device/new_device
    hwclock --hctosys --utc
  fi

	# Tunneling
  modprobe tun
 
  # resize /usr/local to the maximum size of the
  # SD card
  resize_usrlocal

  RF_SERIAL=$(eq3configcmd update-coprocessor -p ${UART_DEV} -c -se 2>&1 | grep "SerialNumber:" | cut -d' ' -f5)
  echo "SerialNumber=${RF_SERIAL}" >>/var/ids
  RF_VERSION=$(eq3configcmd update-coprocessor -p ${UART_DEV} -c -v 2>&1 | grep "Version:" | cut -d' ' -f5)
  echo "Firmware=${RF_VERSION}" >>/var/ids
  RF_ADDRESS=$(eq3configcmd read-default-rf-address -f ${UART_DEV} -h 2>&1 | grep "^0x")
  echo "BidCoS-Address=${RF_ADDRESS}" >>/var/ids

        # cal local init startup file
        if [ ! -e /etc/config/safemode ] ; then
        	if [ -x /usr/local/etc/rc.init ]; then
                	/usr/local/etc/rc.init
        	fi
	fi

	# ToDo GPIO / LED Ports  blink
	echo "18" > /sys/class/gpio/export
	echo "out" > /sys/class/gpio/gpio18/direction
        chmod 775 /var
        mkdir /var/log
        chmod 775 /var/log
        mkdir /var/tmp
        chmod 775 /var/tmp
        mkdir /var/rega
        chmod 775 /var/rega
        mkdir /var/run
        chmod 775 /var/run
        mkdir /var/spool
        chmod 775 /var/spool
        mkdir /var/lock
        chmod 775 /var/lock
        mkdir /var/cache
        chmod 775 /var/cache
        mkdir /var/lib
        chmod 775 /var/lib
        mkdir /var/lib/misc
        chmod 775 /var/lib/misc
        mkdir /var/empty
        chmod 600 /var/empty
        mkdir /var/etc
        chmod 775 /var/etc
        mkdir /var/status
	# HMServer measurement
        chmod 775 /var/status
	touch /var/status/SDinitialised
	mkdir -p /usr/local/sdcard/measurement
	mkdir -p /media/sd-mmcblk0
	ln -sf /usr/local/sdcard/measurement /media/sd-mmcblk0/measurement
	#
	# crontab dirs
        mkdir -p /var/spool/cron
        chmod 775 /var/spool
        chmod 775 /var/spool/cron
        if [ ! -d /usr/local/crontabs ] ; then
        	mkdir -p /usr/local/crontabs
        	chmod 775 /usr/local/crontabs
        fi
	ln -s /usr/local/crontabs /var/spool/cron/crontabs 
        if [ ! -e /usr/local/crontabs/root ] ; then
                cp $CFG_TEMPLATE_DIR/crontab.root /usr/local/crontabs/root
        fi
        # Bug fix
        grep "setInterfaceClock" /usr/local/crontabs/root
        if [ $? == 0 ] ; then
                echo "update crontab file"
                sed 's/setInterfaceClock/SetInterfaceClock/g' /usr/local/crontabs/root > /usr/local/crontabs/root.tmp
                mv /usr/local/crontabs/root.tmp /usr/local/crontabs/root
        fi

	if [ ! -d /usr/local/etc/config ] ; then
                mkdir -p /usr/local/etc/config
        	chmod 775 /usr/local/etc/config
        fi


        if [ ! -e /etc/config/TZ ] ; then
                cp $CFG_TEMPLATE_DIR/TZ /etc/config
        fi
        if [ ! -e /etc/config/netconfig ] ; then
                cp $CFG_TEMPLATE_DIR/netconfig /etc/config
        fi
        if [ ! -s /etc/config/shadow ] ; then
                cp $CFG_TEMPLATE_DIR/shadow /etc/config
        fi

	export TZ=`cat /etc/config/TZ`

	# cal local postinit file
        if [ ! -e /etc/config/safemode ] ; then
		if [ -x /usr/local/etc/rc.postinit ]; then
			/usr/local/etc/rc.postinit
		fi
	fi
 
}

start() {
	echo -n "eQ-3 System start:"
	init
	echo "OK"
	echo -n "Starting crond: "
	start-stop-daemon -S -q -p /var/run/crond.pid --exec /usr/sbin/crond	
	echo "OK"
}

stop () {
	start-stop-daemon -K -q -p /var/run/crond.pid
	/bin/update_firmware_pre
}

restart() {
	start
}

case "$1" in
  start)
	start
	;;
  stop)
	stop
	;;
  restart|reload)
	restart
	;;
  *)
	echo "Usage: $0 {start|stop|restart}"
	exit 1
esac

exit $?

